## 섹션 10. 스프링 트랜잭션 전파1 - 기본

- [BasicTxTest.java](https://github.com/spring-roadmap/spring-db2-transaction/blob/main/src/test/java/hello/springtx/propagation/BasicTxTest.java)

### 스프링 트랜잭션 전파1 - 커밋, 롤백

- commit
- rollback

### 스프링 트랜잭션 전파2 - 트랜잭션 두 번 사용

- double_commit
- double_commit_rollback

### 스프링 트랜잭션 전파3 - 전파 기본

<img width="800" alt="물리 트랜잭션, 논리 트랜잭션" src="https://user-images.githubusercontent.com/64997245/203069513-29d1d7c8-168d-436a-aed9-67a788c85054.png">

#### 물리 트랜잭션, 논리 트랜잭션

- 스프링은 이해를 돕기 위해 논리 트랜잭션과 물리 트랜잭션이라는 개념을 나눈다.
- 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶인다.
- 물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다.
- 실제 커넥션을 통해서 트랜잭션을 시작( setAutoCommit(false)) 하고, 실제 커넥션을 통해서 커밋, 롤백하는 단위이다.
- 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다.

#### 원칙

- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.

### 스프링 트랜잭션 전파4 - 전파 예제

- inner_commit

<img width="504" alt="요청흐름" src="https://user-images.githubusercontent.com/64997245/203071843-1c7aca44-7a11-4ac8-9dfa-07f924a9af6f.png">

#### 요청 흐름 - 외부 트랜잭션

- txManager.getTransaction() 를 호출해서 외부 트랜잭션을 시작한다.
- 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.
- 생성한 커넥션을 수동 커밋 모드( setAutoCommit(false) )로 설정한다. - 물리 트랜잭션 시작
- 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
- 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있다.
- isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 트랜잭션을 처음 시작했으므로 신규 트랜잭션이다.( true )
- 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다.

#### 요청 흐름 - 내부 트랜잭션

- txManager.getTransaction() 를 호출해서 내부 트랜잭션을 시작한다.
- 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다.
- 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여한다.
- 기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻이다.
    - 이미 기존 트랜잭션인 외부 트랜잭션에서 물리 트랜잭션을 시작했다. 그리고 물리 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 담아두었다.
    - 따라서 이미 물리 트랜잭션이 진행중이므로 그냥 두면 이후 로직이 기존에 시작된 트랜잭션을 자연스럽게 사용하게 되는 것이다.
    - 이후 로직은 자연스럽게 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용하게 된다.
- 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에서 isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있다.
- 여기서는 기존 트랜잭션에 참여했기 때문에 신규 트랜잭션이 아니다. ( false )
- 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용한다.

<img width="504" alt="응답흐름" src="https://user-images.githubusercontent.com/64997245/203072079-4edb1edb-12c5-4fcd-85a7-2f3fe4e1f2fa.png">

#### 응답 흐름 - 내부 트랜잭션

- 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.
- 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.
- 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다.
- 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.
- 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다.
- 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다.

#### 응답 흐름 - 외부 트랜잭션

- 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다.
- 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.
- 외부 트랜잭션은 신규 트랜잭션이다.
- 따라서 DB 커넥션에 실제 커밋을 호출한다.
- 트랜잭션 매니저에 커밋하는 것이 논리적인 커밋이라면, 실제 커넥션에 커밋하는 것을 물리 커밋이라 할 수 있다.
- 실제 데이터베이스에 커밋이 반영되고, 물리 트랜잭션도 끝난다.

#### 핵심 정리

- 핵심은 트랜잭션 매니저에 커밋을 호출한다고해서 항상 실제 커넥션에 물리 커밋이 발생하지는 않는다는 점이다.
- 신규 트랜잭션인 경우에만 실제 커넥션을 사용해서 물리 커밋과 롤백을 수행한다.
- 신규 트랜잭션이 아니면 실제 물리 커넥션을 사용하지 않는다.
- 이렇게 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저에 커밋하는 것이 항상 물리 커밋으로 이어지지 않는다.
- 그래서 이 경우 논리 트랜잭션과 물리 트랜잭션을 나누게 된다. 또는 외부 트랜잭션과 내부 트랜잭션으로 나누어 설명하기도 한다.
- 트랜잭션이 내부에서 추가로 사용되면, 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고, 모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋된다고 이해하면 된다.

### 스프링 트랜잭션 전파5 - 외부 롤백

- outer_rollback

### 스프링 트랜잭션 전파6 - 내부 롤백

- inner_rollback
- 내부 트랜잭션 롤백
    - Participating transaction failed - marking existing transaction as rollback-only
    - 내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지 않는다.
    - 대신에 기존 트랜잭션을 롤백 전용으로 표시한다. (트랜잭션 동기화 매니저, rollbackOnly=true)

### 스프링 트랜잭션 전파7 - REQUIRES_NEW

- 외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 각각 별도의 물리 트랜잭션을 사용하는 방법이다.
- 그래서 커밋과 롤백도 각각 별도로 이루어지게 된다.
- 이 방법은 내부 트랜잭션에 문제가 발생해서 롤백해도, 외부 트랜잭션에는 영향을 주지 않는다.
- 반대로 외부 트랜잭션에 문제가 발생해도 내부 트랜잭션에 영향을 주지 않는다.
- inner_rollback_requires_new

#### 정리

- REQUIRES_NEW 옵션을 사용하면 물리 트랜잭션이 명확하게 분리된다.
- REQUIRES_NEW 를 사용하면 데이터베이스 커넥션이 동시에 2개 사용된다는 점을 주의해야 한다.

### 스프링 트랜잭션 전파8 - 다양한 전파 옵션

- 스프링은 다양한 트랜잭션 전파 옵션을 제공한다.
- 전파 옵션에 별도의 설정을 하지 않으면 REQUIRED 가 기본으로 사용된다.
- 참고로 실무에서는 대부분 REQUIRED 옵션을 사용한다.
- 아주 가끔 REQUIRES_NEW 을 사용하고, 나머지는 거의 사용하지 않는다.
- 그래서 나머지 옵션은 이런 것이 있다는 정도로만 알아두고 필요할 때 찾아보자.

#### REQUIRED

- 가장 많이 사용하는 기본 설정이다.
- 기존 트랜잭션이 없으면 생성하고, 있으면 참여한다.
- 트랜잭션이 필수라는 의미로 이해하면 된다. (필수이기 때문에 없으면 만들고, 있으면 참여한다.)
- 기존 트랜잭션 없음: 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음: 기존 트랜잭션에 참여한다.

#### REQUIRES_NEW

- 항상 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 없음: 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음: 새로운 트랜잭션을 생성한다.

#### SUPPORT

- 트랜잭션을 지원한다는 뜻이다.
- 기존 트랜잭션이 없으면, 없는대로 진행하고, 있으면 참여한다.
- 기존 트랜잭션 없음: 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음: 기존 트랜잭션에 참여한다.

#### NOT_SUPPORT

- 트랜잭션을 지원하지 않는다는 의미이다.
- 기존 트랜잭션 없음: 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음: 트랜잭션 없이 진행한다. (기존 트랜잭션은 보류한다)

#### MANDATORY

- 의무사항이다. 트랜잭션이 반드시 있어야 한다.
- 기존 트랜잭션이 없으면 예외가 발생한다.
- 기존 트랜잭션 없음: IllegalTransactionStateException 예외 발생
- 기존 트랜잭션 있음: 기존 트랜잭션에 참여한다.

#### NEVER

- 트랜잭션을 사용하지 않는다는 의미이다.
- 기존 트랜잭션이 있으면 예외가 발생한다.
- 기존 트랜잭션도 허용하지 않는 강한 부정의 의미로 이해하면 된다.
- 기존 트랜잭션 없음: 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음: IllegalTransactionStateException 예외 발생

#### NESTED

- 기존 트랜잭션 없음: 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음: 중첩 트랜잭션을 만든다.
    - 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않는다.
    - 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있다.
    - 외부 트랜잭션이 롤백 되면 중첩 트랜잭션도 함께 롤백된다.

#### 참고

- JDBC savepoint 기능을 사용한다.
- DB 드라이버에서 해당 기능을 지원하는지 확인이 필요하다.
- 중첩 트랜잭션은 JPA에서는 사용할 수 없다.

#### 트랜잭션 전파와 옵션

- isolation , timeout , readOnly 는 트랜잭션이 처음 시작될 때만 적용된다.
- 트랜잭션에 참여하는 경우에는 적용되지 않는다.
- 예를 들어서 REQUIRED 를 통한 트랜잭션 시작, REQUIRES_NEW 를 통한 트랜잭션 시작 시점에만 적용된다.

### 정리
